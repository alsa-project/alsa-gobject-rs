// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

bitflags! {
    /// A set of flags for attributes of event filter.
    #[doc(alias = "ALSASeqFilterAttrFlag")]
    pub struct FilterAttrFlag: u32 {
        /// The client is going to handle broadcast events.
        #[doc(alias = "ALSASEQ_FILTER_ATTR_FLAG_BROADCAST")]
        const BROADCAST = ffi::ALSASEQ_FILTER_ATTR_FLAG_BROADCAST as u32;
        /// The client is going to handle multicast events.
        #[doc(alias = "ALSASEQ_FILTER_ATTR_FLAG_MULTICAST")]
        const MULTICAST = ffi::ALSASEQ_FILTER_ATTR_FLAG_MULTICAST as u32;
        /// The client is going to handle bounce events.
        #[doc(alias = "ALSASEQ_FILTER_ATTR_FLAG_BOUNCE")]
        const BOUNCE = ffi::ALSASEQ_FILTER_ATTR_FLAG_BOUNCE as u32;
    }
}

impl fmt::Display for FilterAttrFlag {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for FilterAttrFlag {
    type GlibType = ffi::ALSASeqFilterAttrFlag;

    fn into_glib(self) -> ffi::ALSASeqFilterAttrFlag {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ALSASeqFilterAttrFlag> for FilterAttrFlag {
    unsafe fn from_glib(value: ffi::ALSASeqFilterAttrFlag) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for FilterAttrFlag {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::alsaseq_filter_attr_flag_get_type()) }
    }
}

impl glib::value::ValueType for FilterAttrFlag {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FilterAttrFlag {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for FilterAttrFlag {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    /// A set of flags for the attributes of port.
    #[doc(alias = "ALSASeqPortAttrFlag")]
    pub struct PortAttrFlag: u32 {
        /// For hardware specific messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_SPECIFIC")]
        const SPECIFIC = ffi::ALSASEQ_PORT_ATTR_FLAG_SPECIFIC as u32;
        /// For generic MIDI messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_MIDI_GENERIC")]
        const MIDI_GENERIC = ffi::ALSASEQ_PORT_ATTR_FLAG_MIDI_GENERIC as u32;
        /// For General MIDI comatible messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_MIDI_GM")]
        const MIDI_GM = ffi::ALSASEQ_PORT_ATTR_FLAG_MIDI_GM as u32;
        /// For GS compatible messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_MIDI_GS")]
        const MIDI_GS = ffi::ALSASEQ_PORT_ATTR_FLAG_MIDI_GS as u32;
        /// For XG compatible messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_MIDI_XG")]
        const MIDI_XG = ffi::ALSASEQ_PORT_ATTR_FLAG_MIDI_XG as u32;
        /// For MT-32 compatible messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_MIDI_MT32")]
        const MIDI_MT32 = ffi::ALSASEQ_PORT_ATTR_FLAG_MIDI_MT32 as u32;
        /// For General MIDI 2 compatible messages.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_MIDI_GM2")]
        const MIDI_GM2 = ffi::ALSASEQ_PORT_ATTR_FLAG_MIDI_GM2 as u32;
        /// The port on any hardware.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_HARDWARE")]
        const HARDWARE = ffi::ALSASEQ_PORT_ATTR_FLAG_HARDWARE as u32;
        /// The port on any software.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_SOFTWARE")]
        const SOFTWARE = ffi::ALSASEQ_PORT_ATTR_FLAG_SOFTWARE as u32;
        /// The port to generate sound.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_SYNTHESIZER")]
        const SYNTHESIZER = ffi::ALSASEQ_PORT_ATTR_FLAG_SYNTHESIZER as u32;
        /// The port connects to the other devices.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_PORT")]
        const PORT = ffi::ALSASEQ_PORT_ATTR_FLAG_PORT as u32;
        /// The port on any application such as sequencer and editor.
        #[doc(alias = "ALSASEQ_PORT_ATTR_FLAG_APPLICATION")]
        const APPLICATION = ffi::ALSASEQ_PORT_ATTR_FLAG_APPLICATION as u32;
    }
}

impl fmt::Display for PortAttrFlag {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for PortAttrFlag {
    type GlibType = ffi::ALSASeqPortAttrFlag;

    fn into_glib(self) -> ffi::ALSASeqPortAttrFlag {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ALSASeqPortAttrFlag> for PortAttrFlag {
    unsafe fn from_glib(value: ffi::ALSASeqPortAttrFlag) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PortAttrFlag {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::alsaseq_port_attr_flag_get_type()) }
    }
}

impl glib::value::ValueType for PortAttrFlag {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PortAttrFlag {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PortAttrFlag {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    /// A set of flags for the capabilities of port.
    #[doc(alias = "ALSASeqPortCapFlag")]
    pub struct PortCapFlag: u32 {
        /// Any message can be read from the port.
        #[doc(alias = "ALSASEQ_PORT_CAP_FLAG_READ")]
        const READ = ffi::ALSASEQ_PORT_CAP_FLAG_READ as u32;
        /// Any message can be written to the port.
        #[doc(alias = "ALSASEQ_PORT_CAP_FLAG_WRITE")]
        const WRITE = ffi::ALSASEQ_PORT_CAP_FLAG_WRITE as u32;
        /// Any messages can be read from/written to the port simultaneously.
        #[doc(alias = "ALSASEQ_PORT_CAP_FLAG_DUPLEX")]
        const DUPLEX = ffi::ALSASEQ_PORT_CAP_FLAG_DUPLEX as u32;
        /// The data of subscription can be read from the port.
        #[doc(alias = "ALSASEQ_PORT_CAP_FLAG_SUBS_READ")]
        const SUBS_READ = ffi::ALSASEQ_PORT_CAP_FLAG_SUBS_READ as u32;
        /// The data of subscription can be written to the port.
        #[doc(alias = "ALSASEQ_PORT_CAP_FLAG_SUBS_WRITE")]
        const SUBS_WRITE = ffi::ALSASEQ_PORT_CAP_FLAG_SUBS_WRITE as u32;
        /// Only owners of the port can maintain subscription.
        #[doc(alias = "ALSASEQ_PORT_CAP_FLAG_NO_EXPORT")]
        const NO_EXPORT = ffi::ALSASEQ_PORT_CAP_FLAG_NO_EXPORT as u32;
    }
}

impl fmt::Display for PortCapFlag {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for PortCapFlag {
    type GlibType = ffi::ALSASeqPortCapFlag;

    fn into_glib(self) -> ffi::ALSASeqPortCapFlag {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ALSASeqPortCapFlag> for PortCapFlag {
    unsafe fn from_glib(value: ffi::ALSASeqPortCapFlag) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PortCapFlag {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::alsaseq_port_cap_flag_get_type()) }
    }
}

impl glib::value::ValueType for PortCapFlag {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PortCapFlag {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PortCapFlag {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    /// A set of flags of the mode of removal event.
    #[doc(alias = "ALSASeqRemoveFilterFlag")]
    pub struct RemoveFilterFlag: u32 {
        /// Flush events in input queues.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_INPUT")]
        const INPUT = ffi::ALSASEQ_REMOVE_FILTER_FLAG_INPUT as u32;
        /// Flush events in output queues.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_OUTPUT")]
        const OUTPUT = ffi::ALSASEQ_REMOVE_FILTER_FLAG_OUTPUT as u32;
        /// Flush events towards the given destination.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_DEST")]
        const DEST = ffi::ALSASEQ_REMOVE_FILTER_FLAG_DEST as u32;
        /// Flush events with the given channel, available for
        ///                                              NOTE, NOTEON, NOTEOFF, KEYPRESS, CONTROLLER, PGMCHANGE, CHANPRESS,
        ///                                              PITCHBEND, CONTROL14, NONREGPARAM, REGPARAM.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_DEST_CHANNEL")]
        const DEST_CHANNEL = ffi::ALSASEQ_REMOVE_FILTER_FLAG_DEST_CHANNEL as u32;
        /// Flush events scheduled before the given time.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_TIME_BEFORE")]
        const TIME_BEFORE = ffi::ALSASEQ_REMOVE_FILTER_FLAG_TIME_BEFORE as u32;
        /// Flush events scheduled after the given time.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_TIME_AFTER")]
        const TIME_AFTER = ffi::ALSASEQ_REMOVE_FILTER_FLAG_TIME_AFTER as u32;
        /// The given time is for tick time.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_TIME_TICK")]
        const TIME_TICK = ffi::ALSASEQ_REMOVE_FILTER_FLAG_TIME_TICK as u32;
        /// Flush events with the type.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_EVENT_TYPE")]
        const EVENT_TYPE = ffi::ALSASEQ_REMOVE_FILTER_FLAG_EVENT_TYPE as u32;
        /// Flush events except for NOTEOFF.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_IGNORE_OFF")]
        const IGNORE_OFF = ffi::ALSASEQ_REMOVE_FILTER_FLAG_IGNORE_OFF as u32;
        /// Flush events with the given tag.
        #[doc(alias = "ALSASEQ_REMOVE_FILTER_FLAG_TAG_MATCH")]
        const TAG_MATCH = ffi::ALSASEQ_REMOVE_FILTER_FLAG_TAG_MATCH as u32;
    }
}

impl fmt::Display for RemoveFilterFlag {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for RemoveFilterFlag {
    type GlibType = ffi::ALSASeqRemoveFilterFlag;

    fn into_glib(self) -> ffi::ALSASeqRemoveFilterFlag {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ALSASeqRemoveFilterFlag> for RemoveFilterFlag {
    unsafe fn from_glib(value: ffi::ALSASeqRemoveFilterFlag) -> Self {
        Self::from_bits_truncate(value)
    }
}

impl StaticType for RemoveFilterFlag {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::alsaseq_remove_filter_flag_get_type()) }
    }
}

impl glib::value::ValueType for RemoveFilterFlag {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RemoveFilterFlag {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for RemoveFilterFlag {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
