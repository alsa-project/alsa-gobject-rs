// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{
    Addr, EventDataConnect, EventDataCtl, EventDataNote, EventDataQueue, EventDataResult,
    EventLengthMode, EventPriorityMode, EventTimeMode, EventTstampMode, EventType,
};
use glib::translate::*;
use std::{mem, ptr};

glib::wrapper! {
    /// A boxed structure for sequencer event.
    ///
    /// A [`Event`][crate::Event] expresses any type of event in ALSA Sequencer. The event consists of some
    /// product-type propertiess and two variant-type properties.
    ///
    /// The instance should be released by call of `boxed_free()` since it can point to the
    /// other allocated object for blob data, therefore it's preferable to use `boxed_copy()`
    /// to duplicate the instance so that the blob data is going to be duplicated as well.
    ///
    /// This is the list of product-type properties:
    ///
    /// - the type of event
    /// - the mode of time stamp
    /// - the mode of time
    /// - the mode of length
    /// - the mode of priority
    /// - the numeric value of tag associated to the event
    /// - the numeric identifier of queue to schedule the event
    /// - destination address
    /// - source address
    ///
    /// One of variant-type property is for time stamp.
    ///
    /// - tick count as time stamp of event
    /// - real time as time stamp of event
    ///
    /// Another variant-type property is for data of event.
    ///
    /// - note
    /// - control
    /// - 12 bytes
    /// - 3 quadlets
    /// - blob as variable length of bytes
    /// - pointer in VMA of user process
    /// - queue control
    /// - tick count as arbitrary time stamp
    /// - real time as arbitrary time stamp
    /// - arbitrary address
    /// - connection between source and destination addresses
    /// - result
    ///
    /// The type of time stamp is associated to the mode of time stamp, while the type of data is
    /// associated to the type of event loosely. Each of the variant type property has single storage
    /// internally, thus an event can includes the sole variant.
    ///
    /// The object wraps `struct snd_seq_event` in UAPI of Linux sound subsystem.
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Event(Boxed<ffi::ALSASeqEvent>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::alsaseq_event_get_type(), ptr as *mut _) as *mut ffi::ALSASeqEvent,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::alsaseq_event_get_type(), ptr as *mut _),
        type_ => || ffi::alsaseq_event_get_type(),
    }
}

impl Event {
    /// Allocate and return an instance of [`Event`][crate::Event].
    /// ## `event_type`
    /// A [`EventType`][crate::EventType].
    ///
    /// # Returns
    ///
    /// An instance of [`Event`][crate::Event].
    #[doc(alias = "alsaseq_event_new")]
    pub fn new(event_type: EventType) -> Event {
        unsafe { from_glib_full(ffi::alsaseq_event_new(event_type.into_glib())) }
    }

    /// Calculate the number of cells in client pool to be consumed when the event is delivered.
    /// The comparison to properties of [`ClientPool`][crate::ClientPool] is useful when scheduling the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `cells`
    /// The number of consumed cells in client pool.
    #[doc(alias = "alsaseq_event_calculate_pool_consumption")]
    pub fn calculate_pool_consumption(&self) -> u32 {
        unsafe {
            let mut cells = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_calculate_pool_consumption(
                self.to_glib_none().0,
                cells.as_mut_ptr(),
            );
            cells.assume_init()
        }
    }

    /// Get the type of event.
    ///
    /// # Returns
    ///
    ///
    /// ## `event_type`
    /// A [`EventType`][crate::EventType].
    #[doc(alias = "alsaseq_event_get_event_type")]
    #[doc(alias = "get_event_type")]
    pub fn event_type(&self) -> EventType {
        unsafe {
            let mut event_type = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_event_type(self.to_glib_none().0, event_type.as_mut_ptr());
            from_glib(event_type.assume_init())
        }
    }

    /// Get the mode of data length for the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `length_mode`
    /// A [`EventLengthMode`][crate::EventLengthMode] for the mode of data length.
    #[doc(alias = "alsaseq_event_get_length_mode")]
    #[doc(alias = "get_length_mode")]
    pub fn length_mode(&self) -> EventLengthMode {
        unsafe {
            let mut length_mode = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_length_mode(self.to_glib_none().0, length_mode.as_mut_ptr());
            from_glib(length_mode.assume_init())
        }
    }

    /// Get the mode of priority for the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `priority_mode`
    /// A [`EventPriorityMode`][crate::EventPriorityMode] The mode of priority.
    #[doc(alias = "alsaseq_event_get_priority_mode")]
    #[doc(alias = "get_priority_mode")]
    pub fn priority_mode(&self) -> EventPriorityMode {
        unsafe {
            let mut priority_mode = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_priority_mode(self.to_glib_none().0, priority_mode.as_mut_ptr());
            from_glib(priority_mode.assume_init())
        }
    }

    /// Get the numeric identifier of queue to schedule the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `queue_id`
    /// The numeric identifier of queue.
    #[doc(alias = "alsaseq_event_get_queue_id")]
    #[doc(alias = "get_queue_id")]
    pub fn queue_id(&self) -> u8 {
        unsafe {
            let mut queue_id = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_queue_id(self.to_glib_none().0, queue_id.as_mut_ptr());
            queue_id.assume_init()
        }
    }

    /// Get the numeric value of tag associated to the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `tag`
    /// The numeric value of tag.
    #[doc(alias = "alsaseq_event_get_tag")]
    #[doc(alias = "get_tag")]
    pub fn tag(&self) -> i8 {
        unsafe {
            let mut tag = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_tag(self.to_glib_none().0, tag.as_mut_ptr());
            tag.assume_init()
        }
    }

    /// Get the mode of time for the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `time_mode`
    /// A [`EventTimeMode`][crate::EventTimeMode] for the mode of time.
    #[doc(alias = "alsaseq_event_get_time_mode")]
    #[doc(alias = "get_time_mode")]
    pub fn time_mode(&self) -> EventTimeMode {
        unsafe {
            let mut time_mode = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_time_mode(self.to_glib_none().0, time_mode.as_mut_ptr());
            from_glib(time_mode.assume_init())
        }
    }

    /// Get the mode of time stamp for the event.
    ///
    /// # Returns
    ///
    ///
    /// ## `tstamp_mode`
    /// A [`EventTstampMode`][crate::EventTstampMode] for the mode of time stamp.
    #[doc(alias = "alsaseq_event_get_tstamp_mode")]
    #[doc(alias = "get_tstamp_mode")]
    pub fn tstamp_mode(&self) -> EventTstampMode {
        unsafe {
            let mut tstamp_mode = mem::MaybeUninit::uninit();
            ffi::alsaseq_event_get_tstamp_mode(self.to_glib_none().0, tstamp_mode.as_mut_ptr());
            from_glib(tstamp_mode.assume_init())
        }
    }

    /// Get the address data of event, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].CLIENT_START
    /// - [`EventType`][crate::EventType].CLIENT_EXIT
    /// - [`EventType`][crate::EventType].CLIENT_CHANGE
    /// - [`EventType`][crate::EventType].PORT_START
    /// - [`EventType`][crate::EventType].PORT_EXIT
    /// - [`EventType`][crate::EventType].PORT_CHANGE
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `data`
    /// The address data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_addr_data")]
    pub fn set_addr_data(&mut self, data: &Addr) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_addr_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Copy the quadlet data to the event, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].SYSEX
    /// - [`EventType`][crate::EventType].BOUNCE
    /// - [`EventType`][crate::EventType].USR_VAR0
    /// - [`EventType`][crate::EventType].USR_VAR1
    /// - [`EventType`][crate::EventType].USR_VAR2
    /// - [`EventType`][crate::EventType].USR_VAR3
    /// - [`EventType`][crate::EventType].USR_VAR4
    /// ## `data`
    /// The pointer to blob data for the event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_blob_data")]
    pub fn set_blob_data(&mut self, data: &[u8]) -> Result<(), glib::Error> {
        let length = data.len() as _;
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_blob_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                length,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Copy the connect data to the event, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].PORT_SUBSCRIBED
    /// - [`EventType`][crate::EventType].PORT_UNSUBSCRIBED
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `data`
    /// The connect data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_connect_data")]
    pub fn set_connect_data(&mut self, data: &EventDataConnect) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_connect_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Copy the control data, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].CONTROLLER
    /// - [`EventType`][crate::EventType].PGMCHANGE
    /// - [`EventType`][crate::EventType].CHANPRESS
    /// - [`EventType`][crate::EventType].PITCHBEND
    /// - [`EventType`][crate::EventType].CONTROL14
    /// - [`EventType`][crate::EventType].NONREGPARAM
    /// - [`EventType`][crate::EventType].REGPARAM
    /// - [`EventType`][crate::EventType].SONGPOS
    /// - [`EventType`][crate::EventType].SONGSEL
    /// - [`EventType`][crate::EventType].QFRAME
    /// - [`EventType`][crate::EventType].TIMESIGN
    /// - [`EventType`][crate::EventType].KEYSIGN
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `data`
    /// The control data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_ctl_data")]
    pub fn set_ctl_data(&mut self, data: &EventDataCtl) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_ctl_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Copy the address as destination of event.
    /// ## `addr`
    /// A [`Addr`][crate::Addr] for event destination.
    #[doc(alias = "alsaseq_event_set_destination")]
    pub fn set_destination(&mut self, addr: &Addr) {
        unsafe {
            ffi::alsaseq_event_set_destination(self.to_glib_none_mut().0, addr.to_glib_none().0);
        }
    }

    /// Copy the note data, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].NOTE
    /// - [`EventType`][crate::EventType].NOTEON
    /// - [`EventType`][crate::EventType].NOTEOFF
    /// - [`EventType`][crate::EventType].KEYPRESS
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `data`
    /// The note data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_note_data")]
    pub fn set_note_data(&mut self, data: &EventDataNote) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_note_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Set the mode of priority for the event.
    /// ## `priority_mode`
    /// A [`EventPriorityMode`][crate::EventPriorityMode] for the mode of priority.
    #[doc(alias = "alsaseq_event_set_priority_mode")]
    pub fn set_priority_mode(&mut self, priority_mode: EventPriorityMode) {
        unsafe {
            ffi::alsaseq_event_set_priority_mode(
                self.to_glib_none_mut().0,
                priority_mode.into_glib(),
            );
        }
    }

    /// Copy the queue data to the event, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].START
    /// - [`EventType`][crate::EventType].CONTINUE
    /// - [`EventType`][crate::EventType].STOP
    /// - [`EventType`][crate::EventType].SETPOS_TICK
    /// - [`EventType`][crate::EventType].SETPOS_TIME
    /// - [`EventType`][crate::EventType].TEMPO
    /// - [`EventType`][crate::EventType].CLOCK
    /// - [`EventType`][crate::EventType].TICK
    /// - [`EventType`][crate::EventType].QUEUE_SKEW
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `data`
    /// The queue data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_queue_data")]
    pub fn set_queue_data(&mut self, data: &EventDataQueue) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_queue_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Set the numeric identifier of queue to schedule the event.
    /// ## `queue_id`
    /// The numeric identifier of queue.
    #[doc(alias = "alsaseq_event_set_queue_id")]
    pub fn set_queue_id(&mut self, queue_id: u8) {
        unsafe {
            ffi::alsaseq_event_set_queue_id(self.to_glib_none_mut().0, queue_id);
        }
    }

    /// Copy the result data to the event, available when [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].SYSTEM
    /// - [`EventType`][crate::EventType].RESULT
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `data`
    /// The result data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_result_data")]
    pub fn set_result_data(&mut self, data: &EventDataResult) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_result_data(
                self.to_glib_none_mut().0,
                data.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Copy the address as source of event.
    /// ## `addr`
    /// A [`Addr`][crate::Addr] for source address.
    #[doc(alias = "alsaseq_event_set_source")]
    pub fn set_source(&mut self, addr: &Addr) {
        unsafe {
            ffi::alsaseq_event_set_source(self.to_glib_none_mut().0, addr.to_glib_none().0);
        }
    }

    /// Set the numeric value of tag associated to the event.
    /// ## `tag`
    /// The numeric value of tag.
    #[doc(alias = "alsaseq_event_set_tag")]
    pub fn set_tag(&mut self, tag: i8) {
        unsafe {
            ffi::alsaseq_event_set_tag(self.to_glib_none_mut().0, tag);
        }
    }

    /// Copy the real time to the event and set [`EventTstampMode`][crate::EventTstampMode].TICK.
    /// ## `tick_time`
    /// The tick time of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_tick_time")]
    pub fn set_tick_time(&mut self, tick_time: u32) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok =
                ffi::alsaseq_event_set_tick_time(self.to_glib_none_mut().0, tick_time, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Copy the tick time data to the event, available when [`tstamp_mode()`][Self::tstamp_mode()] is
    /// [`EventTstampMode`][crate::EventTstampMode].TICK and [`event_type()`][Self::event_type()] results in one of:
    ///
    /// - [`EventType`][crate::EventType].USR0
    /// - [`EventType`][crate::EventType].USR1
    /// - [`EventType`][crate::EventType].USR2
    /// - [`EventType`][crate::EventType].USR3
    /// - [`EventType`][crate::EventType].USR4
    /// - [`EventType`][crate::EventType].USR5
    /// - [`EventType`][crate::EventType].USR6
    /// - [`EventType`][crate::EventType].USR7
    /// - [`EventType`][crate::EventType].USR8
    /// - [`EventType`][crate::EventType].USR9
    /// ## `tick_time`
    /// The tick time data of event.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsaseq_event_set_tick_time_data")]
    pub fn set_tick_time_data(&mut self, tick_time: u32) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsaseq_event_set_tick_time_data(
                self.to_glib_none_mut().0,
                tick_time,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Set the mode of time for the event.
    /// ## `time_mode`
    /// A [`EventTimeMode`][crate::EventTimeMode] for the mode of time.
    #[doc(alias = "alsaseq_event_set_time_mode")]
    pub fn set_time_mode(&mut self, time_mode: EventTimeMode) {
        unsafe {
            ffi::alsaseq_event_set_time_mode(self.to_glib_none_mut().0, time_mode.into_glib());
        }
    }
}

unsafe impl Send for Event {}
