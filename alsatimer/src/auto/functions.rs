// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{DeviceId, DeviceInfo};
use glib::translate::*;

/// Get the information of timer device.
///
/// The call of function executes `open(2)`, `close(2)`, and `ioctl(2)` system call with
/// `SNDRV_TIMER_IOCTL_GINFO` command for ALSA timer character device.
/// ## `device_id`
/// A [`DeviceId`][crate::DeviceId] to identify the timer device.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `device_info`
/// The information of timer device.
#[doc(alias = "alsatimer_get_device_info")]
#[doc(alias = "get_device_info")]
pub fn device_info(device_id: &mut DeviceId) -> Result<DeviceInfo, glib::Error> {
    unsafe {
        let mut device_info = std::ptr::null_mut();
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::alsatimer_get_device_info(
            device_id.to_glib_none_mut().0,
            &mut device_info,
            &mut error,
        );
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(from_glib_full(device_info))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Allocate string of devnode for ALSA Timer and return it if exists.
///
/// Nodes under sound subsystem in sysfs are used to gather the information.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `devnode`
/// The string for devnode of ALSA Timer.
#[doc(alias = "alsatimer_get_devnode")]
#[doc(alias = "get_devnode")]
pub fn devnode() -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut devnode = std::ptr::null_mut();
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::alsatimer_get_devnode(&mut devnode, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(from_glib_full(devnode))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Get `clock_id` for real time.
///
/// The `clock_id` governs real time retrieved by both
/// [`RealTimeEvent::time()`][crate::RealTimeEvent::time()] and
/// [`InstanceStatusExtManual::time()`][crate::prelude::InstanceStatusExtManual::time()].
///
/// The call of function is just to refer to parameter of `snd-timer` kernel module. `0` means
/// `CLOCK_REALTIME` is used. `1` means `CLOCK_MONOTONIC` is used.
///
/// The call of function executes `open(2)`, `read(2)`, `close(2)` system calls for the sysfs node
/// corresponding to the parameter.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `clock_id`
/// The clock_id for real time. The value of `CLOCK_XXX` in UAPI of Linux
///            kernel.
#[doc(alias = "alsatimer_get_real_time_clock_id")]
#[doc(alias = "get_real_time_clock_id")]
pub fn real_time_clock_id() -> Result<i32, glib::Error> {
    unsafe {
        let mut clock_id = std::mem::MaybeUninit::uninit();
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::alsatimer_get_real_time_clock_id(clock_id.as_mut_ptr(), &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(clock_id.assume_init())
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Allocate sysname for ALSA Timer and return it when it exists.
///
/// Nodes under sound subsystem in sysfs are used to gather the information.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `sysname`
/// The string for sysname of ALSA Timer.
#[doc(alias = "alsatimer_get_sysname")]
#[doc(alias = "get_sysname")]
pub fn sysname() -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut sysname = std::ptr::null_mut();
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::alsatimer_get_sysname(&mut sysname, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(from_glib_full(sysname))
        } else {
            Err(from_glib_full(error))
        }
    }
}
