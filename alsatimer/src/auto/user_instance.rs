// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::DeviceId;
use crate::EventType;
use crate::InstanceInfo;
use crate::RealTimeEvent;
use crate::SlaveClass;
use crate::TickTimeEvent;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use std::ptr;

glib::wrapper! {
    /// A GObject-derived object to express user instance.
    ///
    /// A [`UserInstance`][crate::UserInstance] is a GObject-derived object to express information of user instance
    /// attached to any timer device or the other instance as slave. After calling
    /// [`UserInstanceExt::open()`][crate::prelude::UserInstanceExt::open()], the object maintains file descriptor till object destruction. After
    /// calling [`UserInstanceExt::attach()`][crate::prelude::UserInstanceExt::attach()] or [`UserInstanceExt::attach_as_slave()`][crate::prelude::UserInstanceExt::attach_as_slave()], the user instance
    /// is attached to any timer device or the other instance as slave.
    ///
    /// # Implements
    ///
    /// [`UserInstanceExt`][trait@crate::prelude::UserInstanceExt], [`UserInstanceExtManual`][trait@crate::prelude::UserInstanceExtManual]
    #[doc(alias = "ALSATimerUserInstance")]
    pub struct UserInstance(Object<ffi::ALSATimerUserInstance, ffi::ALSATimerUserInstanceClass>);

    match fn {
        type_ => || ffi::alsatimer_user_instance_get_type(),
    }
}

impl UserInstance {
    pub const NONE: Option<&'static UserInstance> = None;

    /// Allocate and return an instance of [`UserInstance`][crate::UserInstance].
    ///
    /// # Returns
    ///
    /// An instance of [`UserInstance`][crate::UserInstance].
    #[doc(alias = "alsatimer_user_instance_new")]
    pub fn new() -> UserInstance {
        unsafe { from_glib_full(ffi::alsatimer_user_instance_new()) }
    }
}

impl Default for UserInstance {
    fn default() -> Self {
        Self::new()
    }
}

/// Trait containing the part of [`struct@UserInstance`] methods.
///
/// # Implementors
///
/// [`UserInstance`][struct@crate::UserInstance]
pub trait UserInstanceExt: 'static {
    /// Attach the instance to the timer device. If the given device_id is for absent timer device, the
    /// instance can be detached with error.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_SELECT` command
    /// for ALSA timer character device.
    /// ## `device_id`
    /// A [`DeviceId`][crate::DeviceId] to which the instance is attached.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_attach")]
    fn attach(&self, device_id: &mut DeviceId) -> Result<(), glib::Error>;

    /// Attach the instance as an slave to another instance indicated by a pair of slave_class and
    /// slave_id. If the slave_class is `SlaveClass:APPLICATION`, the slave_id is for the PID of
    /// application process which owns the instance of timer. If the slave_class is
    /// `SlaveClass:SEQUENCER`, the slave_id is the numeric ID of queue bound for timer device.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_SELECT` command
    /// for ALSA timer character device.
    /// ## `slave_class`
    /// The class identifier of master instance, one of [`SlaveClass`][crate::SlaveClass].
    /// ## `slave_id`
    /// The numeric identifier of master instance.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_attach_as_slave")]
    fn attach_as_slave(&self, slave_class: SlaveClass, slave_id: i32) -> Result<(), glib::Error>;

    /// Choose the type of event data to receive.
    ///
    /// The call of function is successful just before call of [`attach()`][Self::attach()].
    /// [`EventType`][crate::EventType].TICK_TIME is used as a default if the function is not called for
    /// [`EventType`][crate::EventType].REAL_TIME explicitly. When the former is configured, event for tick time is
    /// available for `signal::UserInstance::handle_tick_time_event`. When the latter is configured,
    /// event for real time is available for `signal::UserInstance::handle_real_time_event`.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_TREAD` command
    /// for ALSA timer character device.
    /// ## `event_type`
    /// The type of event data, one of [`EventType`][crate::EventType].
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_choose_event_type")]
    fn choose_event_type(&self, event_type: EventType) -> Result<(), glib::Error>;

    /// Continue timer event emission paused by [`pause()`][Self::pause()].
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_CONTINUE`
    /// command for ALSA timer character device.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_continue")]
    #[doc(alias = "continue")]
    fn continue_(&self) -> Result<(), glib::Error>;

    /// Allocate [`glib::Source`][crate::glib::Source] structure to handle events from ALSA timer character device. In
    /// each iteration of `GLib::MainContext`, the `read(2)` system call is executed to dispatch
    /// timer event for either `signal::UserInstance::handle-tick-time-event` or
    /// `signal::UserInstance::handle-real-time-event` signals, according to the result of `poll(2)`
    /// system call.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    ///
    /// ## `gsrc`
    /// A [`glib::Source`][crate::glib::Source] to handle events from ALSA timer character device.
    #[doc(alias = "alsatimer_user_instance_create_source")]
    fn create_source(&self) -> Result<glib::Source, glib::Error>;

    /// Return the information of device if attached to the instance.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_INFO` command for
    /// ALSA timer character device.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    ///
    /// ## `instance_info`
    /// A [`InstanceInfo`][crate::InstanceInfo].
    #[doc(alias = "alsatimer_user_instance_get_info")]
    #[doc(alias = "get_info")]
    fn info(&self) -> Result<InstanceInfo, glib::Error>;

    /// Open ALSA Timer character device to allocate queue.
    ///
    /// The call of function executes `open(2)` system call for ALSA timer character device.
    /// ## `open_flag`
    /// The flag of `open(2)` system call. `O_RDONLY` is forced to fulfil internally.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_open")]
    fn open(&self, open_flag: i32) -> Result<(), glib::Error>;

    /// Pause timer event emission.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_PAUSE` command
    /// for ALSA timer character device.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_pause")]
    fn pause(&self) -> Result<(), glib::Error>;

    /// Start timer event emission.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_START` command
    /// for ALSA timer character device.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_start")]
    fn start(&self) -> Result<(), glib::Error>;

    /// Stop timer event emission.
    ///
    /// The call of function executes `ioctl(2)` system call with `SNDRV_TIMER_IOCTL_STOP` command
    /// for ALSA timer character device.
    ///
    /// # Returns
    ///
    /// [`true`] when the overall operation finishes successfully, else [`false`].
    #[doc(alias = "alsatimer_user_instance_stop")]
    fn stop(&self) -> Result<(), glib::Error>;

    /// Emitted when the attached timer device is not available anymore due to unbinding driver or
    /// hot unplugging. The owner of this object should call `GObject::Object::unref()` as quickly
    /// as possible to release ALSA timer character device.
    #[doc(alias = "handle-disconnection")]
    fn connect_handle_disconnection<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    /// Emitted when event occurs to notify real time.
    /// ## `event`
    /// The instance of [`RealTimeEvent`][crate::RealTimeEvent].
    #[doc(alias = "handle-real-time-event")]
    fn connect_handle_real_time_event<F: Fn(&Self, &RealTimeEvent) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;

    /// Emitted when event occurs to notify tick time.
    /// ## `event`
    /// The instance of [`TickTimeEvent`][crate::TickTimeEvent].
    #[doc(alias = "handle-tick-time-event")]
    fn connect_handle_tick_time_event<F: Fn(&Self, &TickTimeEvent) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId;
}

impl<O: IsA<UserInstance>> UserInstanceExt for O {
    fn attach(&self, device_id: &mut DeviceId) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsatimer_user_instance_attach(
                self.as_ref().to_glib_none().0,
                device_id.to_glib_none_mut().0,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn attach_as_slave(&self, slave_class: SlaveClass, slave_id: i32) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsatimer_user_instance_attach_as_slave(
                self.as_ref().to_glib_none().0,
                slave_class.into_glib(),
                slave_id,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn choose_event_type(&self, event_type: EventType) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsatimer_user_instance_choose_event_type(
                self.as_ref().to_glib_none().0,
                event_type.into_glib(),
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn continue_(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok =
                ffi::alsatimer_user_instance_continue(self.as_ref().to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn create_source(&self) -> Result<glib::Source, glib::Error> {
        unsafe {
            let mut gsrc = ptr::null_mut();
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsatimer_user_instance_create_source(
                self.as_ref().to_glib_none().0,
                &mut gsrc,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(from_glib_full(gsrc))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn info(&self) -> Result<InstanceInfo, glib::Error> {
        unsafe {
            let mut instance_info = ptr::null_mut();
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsatimer_user_instance_get_info(
                self.as_ref().to_glib_none().0,
                &mut instance_info,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(from_glib_full(instance_info))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn open(&self, open_flag: i32) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::alsatimer_user_instance_open(
                self.as_ref().to_glib_none().0,
                open_flag,
                &mut error,
            );
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn pause(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok =
                ffi::alsatimer_user_instance_pause(self.as_ref().to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn start(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok =
                ffi::alsatimer_user_instance_start(self.as_ref().to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn stop(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok =
                ffi::alsatimer_user_instance_stop(self.as_ref().to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    fn connect_handle_disconnection<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn handle_disconnection_trampoline<
            P: IsA<UserInstance>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::ALSATimerUserInstance,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(UserInstance::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"handle-disconnection\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    handle_disconnection_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_handle_real_time_event<F: Fn(&Self, &RealTimeEvent) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn handle_real_time_event_trampoline<
            P: IsA<UserInstance>,
            F: Fn(&P, &RealTimeEvent) + 'static,
        >(
            this: *mut ffi::ALSATimerUserInstance,
            event: *mut ffi::ALSATimerRealTimeEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                UserInstance::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"handle-real-time-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    handle_real_time_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_handle_tick_time_event<F: Fn(&Self, &TickTimeEvent) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn handle_tick_time_event_trampoline<
            P: IsA<UserInstance>,
            F: Fn(&P, &TickTimeEvent) + 'static,
        >(
            this: *mut ffi::ALSATimerUserInstance,
            event: *mut ffi::ALSATimerTickTimeEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                UserInstance::from_glib_borrow(this).unsafe_cast_ref(),
                &from_glib_borrow(event),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"handle-tick-time-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    handle_tick_time_event_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for UserInstance {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("UserInstance")
    }
}
