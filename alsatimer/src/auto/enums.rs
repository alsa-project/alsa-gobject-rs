// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use alsatimer_sys;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Class {
    None,
    Global,
    Card,
    Pcm,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Class {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Class::{}",
            match *self {
                Class::None => "None",
                Class::Global => "Global",
                Class::Card => "Card",
                Class::Pcm => "Pcm",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Class {
    type GlibType = alsatimer_sys::ALSATimerClass;

    fn to_glib(&self) -> alsatimer_sys::ALSATimerClass {
        match *self {
            Class::None => alsatimer_sys::ALSATIMER_CLASS_NONE,
            Class::Global => alsatimer_sys::ALSATIMER_CLASS_GLOBAL,
            Class::Card => alsatimer_sys::ALSATIMER_CLASS_CARD,
            Class::Pcm => alsatimer_sys::ALSATIMER_CLASS_PCM,
            Class::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<alsatimer_sys::ALSATimerClass> for Class {
    fn from_glib(value: alsatimer_sys::ALSATimerClass) -> Self {
        match value {
            -1 => Class::None,
            1 => Class::Global,
            2 => Class::Card,
            3 => Class::Pcm,
            value => Class::__Unknown(value),
        }
    }
}

impl StaticType for Class {
    fn static_type() -> Type {
        unsafe { from_glib(alsatimer_sys::alsatimer_class_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Class {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Class {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Class {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum EventType {
    TickTime,
    RealTime,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EventType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EventType::{}",
            match *self {
                EventType::TickTime => "TickTime",
                EventType::RealTime => "RealTime",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for EventType {
    type GlibType = alsatimer_sys::ALSATimerEventType;

    fn to_glib(&self) -> alsatimer_sys::ALSATimerEventType {
        match *self {
            EventType::TickTime => alsatimer_sys::ALSATIMER_EVENT_TYPE_TICK_TIME,
            EventType::RealTime => alsatimer_sys::ALSATIMER_EVENT_TYPE_REAL_TIME,
            EventType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<alsatimer_sys::ALSATimerEventType> for EventType {
    fn from_glib(value: alsatimer_sys::ALSATimerEventType) -> Self {
        match value {
            0 => EventType::TickTime,
            1 => EventType::RealTime,
            value => EventType::__Unknown(value),
        }
    }
}

impl StaticType for EventType {
    fn static_type() -> Type {
        unsafe { from_glib(alsatimer_sys::alsatimer_event_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for EventType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for EventType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for EventType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RealTimeEventType {
    Resolution,
    Tick,
    Start,
    Stop,
    Continue,
    Pause,
    Early,
    Suspend,
    Resume,
    Mstart,
    Mstop,
    Mcontinue,
    Mpause,
    Msuspend,
    Mresume,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RealTimeEventType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RealTimeEventType::{}",
            match *self {
                RealTimeEventType::Resolution => "Resolution",
                RealTimeEventType::Tick => "Tick",
                RealTimeEventType::Start => "Start",
                RealTimeEventType::Stop => "Stop",
                RealTimeEventType::Continue => "Continue",
                RealTimeEventType::Pause => "Pause",
                RealTimeEventType::Early => "Early",
                RealTimeEventType::Suspend => "Suspend",
                RealTimeEventType::Resume => "Resume",
                RealTimeEventType::Mstart => "Mstart",
                RealTimeEventType::Mstop => "Mstop",
                RealTimeEventType::Mcontinue => "Mcontinue",
                RealTimeEventType::Mpause => "Mpause",
                RealTimeEventType::Msuspend => "Msuspend",
                RealTimeEventType::Mresume => "Mresume",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RealTimeEventType {
    type GlibType = alsatimer_sys::ALSATimerRealTimeEventType;

    fn to_glib(&self) -> alsatimer_sys::ALSATimerRealTimeEventType {
        match *self {
            RealTimeEventType::Resolution => {
                alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_RESOLUTION
            }
            RealTimeEventType::Tick => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_TICK,
            RealTimeEventType::Start => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_START,
            RealTimeEventType::Stop => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_STOP,
            RealTimeEventType::Continue => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_CONTINUE,
            RealTimeEventType::Pause => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_PAUSE,
            RealTimeEventType::Early => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_EARLY,
            RealTimeEventType::Suspend => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_SUSPEND,
            RealTimeEventType::Resume => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_RESUME,
            RealTimeEventType::Mstart => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_MSTART,
            RealTimeEventType::Mstop => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_MSTOP,
            RealTimeEventType::Mcontinue => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_MCONTINUE,
            RealTimeEventType::Mpause => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_MPAUSE,
            RealTimeEventType::Msuspend => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_MSUSPEND,
            RealTimeEventType::Mresume => alsatimer_sys::ALSATIMER_REAL_TIME_EVENT_TYPE_MRESUME,
            RealTimeEventType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<alsatimer_sys::ALSATimerRealTimeEventType> for RealTimeEventType {
    fn from_glib(value: alsatimer_sys::ALSATimerRealTimeEventType) -> Self {
        match value {
            0 => RealTimeEventType::Resolution,
            1 => RealTimeEventType::Tick,
            2 => RealTimeEventType::Start,
            3 => RealTimeEventType::Stop,
            4 => RealTimeEventType::Continue,
            5 => RealTimeEventType::Pause,
            6 => RealTimeEventType::Early,
            7 => RealTimeEventType::Suspend,
            8 => RealTimeEventType::Resume,
            12 => RealTimeEventType::Mstart,
            13 => RealTimeEventType::Mstop,
            14 => RealTimeEventType::Mcontinue,
            15 => RealTimeEventType::Mpause,
            17 => RealTimeEventType::Msuspend,
            18 => RealTimeEventType::Mresume,
            value => RealTimeEventType::__Unknown(value),
        }
    }
}

impl StaticType for RealTimeEventType {
    fn static_type() -> Type {
        unsafe { from_glib(alsatimer_sys::alsatimer_real_time_event_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RealTimeEventType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RealTimeEventType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RealTimeEventType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SlaveClass {
    None,
    Application,
    Sequencer,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SlaveClass {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SlaveClass::{}",
            match *self {
                SlaveClass::None => "None",
                SlaveClass::Application => "Application",
                SlaveClass::Sequencer => "Sequencer",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SlaveClass {
    type GlibType = alsatimer_sys::ALSATimerSlaveClass;

    fn to_glib(&self) -> alsatimer_sys::ALSATimerSlaveClass {
        match *self {
            SlaveClass::None => alsatimer_sys::ALSATIMER_SLAVE_CLASS_NONE,
            SlaveClass::Application => alsatimer_sys::ALSATIMER_SLAVE_CLASS_APPLICATION,
            SlaveClass::Sequencer => alsatimer_sys::ALSATIMER_SLAVE_CLASS_SEQUENCER,
            SlaveClass::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<alsatimer_sys::ALSATimerSlaveClass> for SlaveClass {
    fn from_glib(value: alsatimer_sys::ALSATimerSlaveClass) -> Self {
        match value {
            0 => SlaveClass::None,
            1 => SlaveClass::Application,
            2 => SlaveClass::Sequencer,
            value => SlaveClass::__Unknown(value),
        }
    }
}

impl StaticType for SlaveClass {
    fn static_type() -> Type {
        unsafe { from_glib(alsatimer_sys::alsatimer_slave_class_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SlaveClass {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SlaveClass {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SlaveClass {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SpecificGlobalDevice {
    System,
    Hrtimer,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SpecificGlobalDevice {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SpecificGlobalDevice::{}",
            match *self {
                SpecificGlobalDevice::System => "System",
                SpecificGlobalDevice::Hrtimer => "Hrtimer",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SpecificGlobalDevice {
    type GlibType = alsatimer_sys::ALSATimerSpecificGlobalDevice;

    fn to_glib(&self) -> alsatimer_sys::ALSATimerSpecificGlobalDevice {
        match *self {
            SpecificGlobalDevice::System => alsatimer_sys::ALSATIMER_SPECIFIC_GLOBAL_DEVICE_SYSTEM,
            SpecificGlobalDevice::Hrtimer => {
                alsatimer_sys::ALSATIMER_SPECIFIC_GLOBAL_DEVICE_HRTIMER
            }
            SpecificGlobalDevice::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<alsatimer_sys::ALSATimerSpecificGlobalDevice> for SpecificGlobalDevice {
    fn from_glib(value: alsatimer_sys::ALSATimerSpecificGlobalDevice) -> Self {
        match value {
            0 => SpecificGlobalDevice::System,
            3 => SpecificGlobalDevice::Hrtimer,
            value => SpecificGlobalDevice::__Unknown(value),
        }
    }
}

impl StaticType for SpecificGlobalDevice {
    fn static_type() -> Type {
        unsafe { from_glib(alsatimer_sys::alsatimer_specific_global_device_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SpecificGlobalDevice {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SpecificGlobalDevice {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SpecificGlobalDevice {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum UserInstanceError {
    Failed,
    TimerNotFound,
    NotAttached,
    Attached,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for UserInstanceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UserInstanceError::{}",
            match *self {
                UserInstanceError::Failed => "Failed",
                UserInstanceError::TimerNotFound => "TimerNotFound",
                UserInstanceError::NotAttached => "NotAttached",
                UserInstanceError::Attached => "Attached",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for UserInstanceError {
    type GlibType = alsatimer_sys::ALSATimerUserInstanceError;

    fn to_glib(&self) -> alsatimer_sys::ALSATimerUserInstanceError {
        match *self {
            UserInstanceError::Failed => alsatimer_sys::ALSATIMER_USER_INSTANCE_ERROR_FAILED,
            UserInstanceError::TimerNotFound => {
                alsatimer_sys::ALSATIMER_USER_INSTANCE_ERROR_TIMER_NOT_FOUND
            }
            UserInstanceError::NotAttached => {
                alsatimer_sys::ALSATIMER_USER_INSTANCE_ERROR_NOT_ATTACHED
            }
            UserInstanceError::Attached => alsatimer_sys::ALSATIMER_USER_INSTANCE_ERROR_ATTACHED,
            UserInstanceError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<alsatimer_sys::ALSATimerUserInstanceError> for UserInstanceError {
    fn from_glib(value: alsatimer_sys::ALSATimerUserInstanceError) -> Self {
        match value {
            0 => UserInstanceError::Failed,
            1 => UserInstanceError::TimerNotFound,
            2 => UserInstanceError::NotAttached,
            3 => UserInstanceError::Attached,
            value => UserInstanceError::__Unknown(value),
        }
    }
}

impl ErrorDomain for UserInstanceError {
    fn domain() -> Quark {
        unsafe { from_glib(alsatimer_sys::alsatimer_user_instance_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(UserInstanceError::Failed),
            1 => Some(UserInstanceError::TimerNotFound),
            2 => Some(UserInstanceError::NotAttached),
            3 => Some(UserInstanceError::Attached),
            _ => Some(UserInstanceError::Failed),
        }
    }
}

impl StaticType for UserInstanceError {
    fn static_type() -> Type {
        unsafe { from_glib(alsatimer_sys::alsatimer_user_instance_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for UserInstanceError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for UserInstanceError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for UserInstanceError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
