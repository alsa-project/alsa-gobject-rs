// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use std::mem;
use std::ptr;

/// Get the list of numeric ID for available sound cards.
///
/// Nodes under sound subsystem in sysfs are used to gather the information.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `entries`
/// The list of numeric ID for sound cards.
#[doc(alias = "alsactl_get_card_id_list")]
#[doc(alias = "get_card_id_list")]
pub fn card_id_list() -> Result<Vec<u32>, glib::Error> {
    unsafe {
        let mut entries = ptr::null_mut();
        let mut entry_count = mem::MaybeUninit::uninit();
        let mut error = ptr::null_mut();
        let is_ok =
            ffi::alsactl_get_card_id_list(&mut entries, entry_count.as_mut_ptr(), &mut error);
        assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(FromGlibContainer::from_glib_full_num(
                entries,
                entry_count.assume_init() as usize,
            ))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Allocate sysname for the sound card and return it when it exists.
///
/// Nodes under sound subsystem in sysfs are used to gather the information.
/// ## `card_id`
/// The numeric ID of sound card.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `sysname`
/// The string for sysname of the sound card.
#[doc(alias = "alsactl_get_card_sysname")]
#[doc(alias = "get_card_sysname")]
pub fn card_sysname(card_id: u32) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut sysname = ptr::null_mut();
        let mut error = ptr::null_mut();
        let is_ok = ffi::alsactl_get_card_sysname(card_id, &mut sysname, &mut error);
        assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(from_glib_full(sysname))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Allocate string of devnode for control device of the sound card and return it if exists.
///
/// Nodes under sound subsystem in sysfs are used to gather the information.
/// ## `card_id`
/// The numeric ID of sound card.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `devnode`
/// The string for devnode of control device for the sound card.
#[doc(alias = "alsactl_get_control_devnode")]
#[doc(alias = "get_control_devnode")]
pub fn control_devnode(card_id: u32) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut devnode = ptr::null_mut();
        let mut error = ptr::null_mut();
        let is_ok = ffi::alsactl_get_control_devnode(card_id, &mut devnode, &mut error);
        assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(from_glib_full(devnode))
        } else {
            Err(from_glib_full(error))
        }
    }
}

/// Allocate sysname of control device for the sound card and return it if exists.
///
/// Nodes under sound subsystem in sysfs are used to gather the information.
/// ## `card_id`
/// The numeridcal ID of sound card.
///
/// # Returns
///
/// [`true`] when the overall operation finishes successfully, else [`false`].
///
/// ## `sysname`
/// The string for sysname of control device for the sound card.
#[doc(alias = "alsactl_get_control_sysname")]
#[doc(alias = "get_control_sysname")]
pub fn control_sysname(card_id: u32) -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut sysname = ptr::null_mut();
        let mut error = ptr::null_mut();
        let is_ok = ffi::alsactl_get_control_sysname(card_id, &mut sysname, &mut error);
        assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() {
            Ok(from_glib_full(sysname))
        } else {
            Err(from_glib_full(error))
        }
    }
}

//#[doc(alias = "alsactl_sigs_marshal_VOID__BOXED_FLAGS")]
//pub fn sigs_marshal_VOID__BOXED_FLAGS(closure: /*Ignored*/&glib::Closure, return_value: /*Ignored*/&mut glib::Value, n_param_values: u32, param_values: /*Ignored*/&glib::Value, invocation_hint: /*Unimplemented*/Option<Fundamental: Pointer>, marshal_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
//    unsafe { TODO: call ffi:alsactl_sigs_marshal_VOID__BOXED_FLAGS() }
//}
